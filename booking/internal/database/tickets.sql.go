// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tickets.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getPurchaseDetails = `-- name: GetPurchaseDetails :one
SELECT 
    p.id as purchase_id,
    p.total_cents,
    p.created_at as purchase_created_at,
    json_agg(
        json_build_object(
            'id', t.id,
            'event_id', t.event_id,
            'ticket_type_id', t.ticket_type_id,
            'status', t.status,
            'ticket_type_name', tt.name,
            'ticket_type_display_name', tt.display_name,
            'ticket_type_price_cents', tt.price_cents
        )
    ) as tickets
FROM purchases p
JOIN tickets t ON t.purchase_id = p.id
JOIN ticket_types tt ON t.ticket_type_id = tt.id
WHERE p.id = $1
GROUP BY p.id, p.total_cents, p.created_at
`

type GetPurchaseDetailsRow struct {
	PurchaseID        uuid.UUID
	TotalCents        int32
	PurchaseCreatedAt time.Time
	Tickets           json.RawMessage
}

// need to test this query performance; can converted to view?
func (q *Queries) GetPurchaseDetails(ctx context.Context, id uuid.UUID) (GetPurchaseDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getPurchaseDetails, id)
	var i GetPurchaseDetailsRow
	err := row.Scan(
		&i.PurchaseID,
		&i.TotalCents,
		&i.PurchaseCreatedAt,
		&i.Tickets,
	)
	return i, err
}

const getTicketStatus = `-- name: GetTicketStatus :one
SELECT status FROM tickets WHERE id = $1
`

func (q *Queries) GetTicketStatus(ctx context.Context, id uuid.UUID) (TicketStatus, error) {
	row := q.db.QueryRowContext(ctx, getTicketStatus, id)
	var status TicketStatus
	err := row.Scan(&status)
	return status, err
}

const getTicketWithPrice = `-- name: GetTicketWithPrice :one
SELECT 
    t.id,
    t.event_id,
    t.ticket_type_id,
    t.status,
    tt.price_cents
FROM tickets t
JOIN ticket_types tt ON t.ticket_type_id = tt.id
WHERE t.id = $1
`

type GetTicketWithPriceRow struct {
	ID           uuid.UUID
	EventID      uuid.UUID
	TicketTypeID uuid.UUID
	Status       TicketStatus
	PriceCents   int32
}

func (q *Queries) GetTicketWithPrice(ctx context.Context, id uuid.UUID) (GetTicketWithPriceRow, error) {
	row := q.db.QueryRowContext(ctx, getTicketWithPrice, id)
	var i GetTicketWithPriceRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.TicketTypeID,
		&i.Status,
		&i.PriceCents,
	)
	return i, err
}

const purchaseTicket = `-- name: PurchaseTicket :exec
UPDATE tickets
SET status = 'sold'
WHERE id = $1 AND status = 'available'
`

func (q *Queries) PurchaseTicket(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, purchaseTicket, id)
	return err
}

const purchaseTickets = `-- name: PurchaseTickets :one
WITH purchase_insert AS (
    INSERT INTO purchases (total_cents)
    VALUES ($1)
    RETURNING id
),
updated_tickets AS (
    UPDATE tickets
    SET status = 'sold', purchase_id = (SELECT id FROM purchase_insert)
    WHERE id = ANY($2::uuid[]) AND status = 'available'
    RETURNING purchase_id
)
SELECT id FROM purchase_insert
`

type PurchaseTicketsParams struct {
	TotalCents int32
	Column2    []uuid.UUID
}

// This query creates a purchase record and updates all tickets atomically
func (q *Queries) PurchaseTickets(ctx context.Context, arg PurchaseTicketsParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, purchaseTickets, arg.TotalCents, pq.Array(arg.Column2))
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
