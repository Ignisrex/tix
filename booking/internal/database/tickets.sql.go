// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tickets.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getPurchaseDetails = `-- name: GetPurchaseDetails :one
SELECT 
    p.id as purchase_id,
    p.total_cents,
    p.created_at as purchase_created_at,
    json_agg(
        json_build_object(
            'id', t.id,
            'event_id', t.event_id,
            'ticket_type_id', t.ticket_type_id,
            'status', t.status,
            'ticket_type_name', tt.name,
            'ticket_type_display_name', tt.display_name,
            'ticket_type_price_cents', tt.price_cents
        )
    ) as tickets
FROM purchases p
JOIN tickets t ON t.purchase_id = p.id
JOIN ticket_types tt ON t.ticket_type_id = tt.id
WHERE p.id = $1
GROUP BY p.id, p.total_cents, p.created_at
`

type GetPurchaseDetailsRow struct {
	PurchaseID        uuid.UUID
	TotalCents        int32
	PurchaseCreatedAt time.Time
	Tickets           json.RawMessage
}

// need to test this query performance; can converted to view?
func (q *Queries) GetPurchaseDetails(ctx context.Context, id uuid.UUID) (GetPurchaseDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getPurchaseDetails, id)
	var i GetPurchaseDetailsRow
	err := row.Scan(
		&i.PurchaseID,
		&i.TotalCents,
		&i.PurchaseCreatedAt,
		&i.Tickets,
	)
	return i, err
}

const getTicketsWithPrice = `-- name: GetTicketsWithPrice :many
SELECT 
    t.id,
    t.event_id,
    t.ticket_type_id,
    t.status,
    tt.price_cents
FROM tickets t
JOIN ticket_types tt ON t.ticket_type_id = tt.id
WHERE t.id = ANY($1::uuid[])
`

type GetTicketsWithPriceRow struct {
	ID           uuid.UUID
	EventID      uuid.UUID
	TicketTypeID uuid.UUID
	Status       TicketStatus
	PriceCents   int32
}

func (q *Queries) GetTicketsWithPrice(ctx context.Context, dollar_1 []uuid.UUID) ([]GetTicketsWithPriceRow, error) {
	rows, err := q.db.QueryContext(ctx, getTicketsWithPrice, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTicketsWithPriceRow
	for rows.Next() {
		var i GetTicketsWithPriceRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.TicketTypeID,
			&i.Status,
			&i.PriceCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purchaseTickets = `-- name: PurchaseTickets :one
WITH purchase_insert AS (
    INSERT INTO purchases (total_cents)
    VALUES ($1)
    RETURNING id
),
updated_tickets AS (
    UPDATE tickets
    SET status = 'sold', purchase_id = (SELECT id FROM purchase_insert)
    WHERE id = ANY($2::uuid[]) AND status = 'available'
    RETURNING purchase_id
)
SELECT id FROM purchase_insert
`

type PurchaseTicketsParams struct {
	TotalCents int32
	Column2    []uuid.UUID
}

// This query creates a purchase record and updates all tickets atomically
func (q *Queries) PurchaseTickets(ctx context.Context, arg PurchaseTicketsParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, purchaseTickets, arg.TotalCents, pq.Array(arg.Column2))
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
